// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.
/*----------------------------------------------------------------------------*/

package frc.robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import frc.robot.subsystems.DriveTrain;
import frc.robot.Constants.DriveConstants;
import frc.robot.RobotContainer;
import frc.robot.RobotContainer.*;
import java.util.function.DoubleSupplier;
import frc.robot.OI;

/**
 * Creates teleop drivetrain drive command
  * @author 23BBrenner
 */
public class DriveCommand extends CommandBase {

    // DriveCommand Variable Declarations 

    // DriveCommand Constructors
    private RobotContainer m_robotContainer;
    private DriveTrain m_drivetrain; // = DriveTrain.getInstance();
    // private OI m_oi;
    private XboxController m_driveController;
    private int m_driverControlsChoice;
    private int m_driveModeChoice;
    private int m_controllerScalingChoice;
       
    public DriveCommand(DriveTrain subsystem, XboxController controller) {
        m_drivetrain = subsystem;
        m_driveController = controller; 
        m_driverControlsChoice = OI.getInstance().getDriverControlsChooser();
        m_driveModeChoice = OI.getInstance().getDriveModeChooser();
        m_controllerScalingChoice = OI.getInstance().getControllerScalingChooser();
        // Ensures that two commands that need the same subsystem dont mess each other up. 
        addRequirements (m_drivetrain);  
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        double speed = 0;
        double rotation = 0;

        driverControls(speed, m_driverControlsChoice);
        rotation = (m_driveController.getLeftX() * DriveConstants.kRotationOutputModifier);

        //controllerScaling(speed, rotation, m_controllerScalingChoice);
        scalingRotation(rotation, m_controllerScalingChoice);
        scalingSpeed(speed, m_controllerScalingChoice);

        driveMode(speed, rotation, m_driveModeChoice);

        double leftSpeed = speed + rotation;
        double rightSpeed = speed - rotation;

        double max = Math.max(leftSpeed, rightSpeed);

        if(max > 1) {
			leftSpeed /= max;
			rightSpeed /= max;
		}

        m_drivetrain.setWheelSpeeds(leftSpeed, rightSpeed);
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    }

    public double driverControls(double speed, int choice) {
            if (choice == 0){ //default left stick controls
                speed = (m_driveController.getLeftY() * DriveConstants.kSpeedOutputModifier);
            } else { //accelerated with trigger controls
                speed = ((m_driveController.getLeftTriggerAxis() - m_driveController.getRightTriggerAxis()) * DriveConstants.kSpeedOutputModifier);
            }
            return speed;
        }

    // public void controllerScaling(double speed, double rotation, int choice) {
    //    scalingSpeed(rotation, choice);
    //    scalingRotation(speed, choice);
    // }

        public double scalingSpeed(double speed, int choice){
            if (choice == 0){ //linear scaling
                return speed; 
            }
            if (choice == 1) { //quadratic scaling
                speed = Math.copySign(speed * speed, speed);
            }
            if (choice == 2) { //cubic scaling
                speed = speed * speed * speed;
            }
            if (choice == 3) { //non polynomic
                speed = speed * 0.5 + Math.pow(3,(speed * 0.5));
            }
            return speed;
        }

        public double scalingRotation(double rotation, int choice){
            if (choice == 0){ //linear scaling
                return rotation; 
            }
            if (choice == 1) { //quadratic scaling
                rotation = Math.copySign(rotation * rotation, rotation);
            }
            if (choice == 2) { //cubic scaling
                rotation = Math.pow(3, rotation);
            }
            if (choice == 3) { //non polynomic
                rotation = rotation * 0.5 + Math.pow(3,(rotation * 0.5));
            }
            return rotation;
        }

    public void driveMode(double speed, double rotation, int choice){
        if (choice == 0){ //semi-curvature
            m_drivetrain.curvatureDrive(speed,rotation,true);
        }
        if (choice == 1){ //regular curvature
            m_drivetrain.curvatureDrive(speed, rotation, false);
        }
        if (choice == 2){ //arcade
            m_drivetrain.arcadeDrive(speed, rotation);
        }
    }

    

    
}